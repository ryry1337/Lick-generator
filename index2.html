<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lick Generator</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap">
<style>
  :root{
    --bg:#0f1720; --card:#0b1220; --accent:#8bdcff; --muted:#9aa6b2; --glass: rgba(255,255,255,0.03);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#081020,#0f1720);color:#e6eef6}
  .wrap{max-width:980px;margin:28px auto;padding:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);}
  h1{margin:0 0 10px;font-weight:600}
  p.lead{margin:0 0 18px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
  @media(max-width:720px){.grid{grid-template-columns:1fr}}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  select,input[type=range],input[type=number],button{
    width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);
    background:transparent;color:inherit;font-size:14px;
  }
  .row{display:flex;gap:8px}
  .row > *{flex:1}
  .footer{display:flex;gap:10px;align-items:center;margin-top:14px}
  .big {display:flex;gap:8px}
  button{cursor:pointer;background:linear-gradient(90deg,var(--accent),#6bd8ff);color:#012; font-weight:600;border:none;padding:10px 14px;border-radius:10px}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .panel{margin-top:18px;padding:12px;border-radius:10px;background:var(--glass);min-height:120px}
  .notes{display:flex;flex-wrap:wrap;gap:8px}
  .note-pill{padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:8px;font-weight:600}
  .meta{font-size:13px;color:var(--muted);margin-top:8px}
  .small{font-size:12px;color:var(--muted)}
  input[type=range]{-webkit-appearance:none;height:6px;background:rgba(255,255,255,0.04);border-radius:6px}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;background:var(--accent);border-radius:50%}
  .range-labels{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);margin-top:6px}
  .genre-tip{font-size:12px;color:var(--muted);margin-top:6px}
  .kbd{background:rgba(255,255,255,0.04);padding:4px 8px;border-radius:6px;font-weight:600}
</style>
</head>
<body>
<div class="wrap">
  <h1>Lick Generator</h1>
  <p class="lead">Generate ear-training licks that feel human and genre-true. Tap Generate, then Play. Mobile-friendly.</p>

  <div class="grid">
    <div>
      <label>Key</label>
      <select id="key">
        <!-- common keys -->
        <option value="C">C</option><option value="G">G</option><option value="D">D</option><option value="A">A</option><option value="E">E</option>
        <option value="B">B</option><option value="F#">F#</option><option value="Gb">Gb</option><option value="Db">Db</option>
        <option value="Ab">Ab</option><option value="Eb">Eb</option><option value="Bb">Bb</option><option value="F">F</option>
      </select>
    </div>

    <div>
      <label>Mode / Scale</label>
      <select id="mode">
        <option value="ionian">Ionian (major)</option>
        <option value="dorian">Dorian</option>
        <option value="phrygian">Phrygian</option>
        <option value="lydian">Lydian</option>
        <option value="mixolydian">Mixolydian</option>
        <option value="aeolian">Aeolian (minor)</option>
        <option value="locrian">Locrian</option>
        <option value="harmonic_minor">Harmonic minor</option>
        <option value="melodic_minor">Melodic minor</option>
        <option value="pentatonic_major">Pentatonic major</option>
        <option value="pentatonic_minor">Pentatonic minor</option>
        <option value="chromatic">Chromatic (for jazz)</option>
      </select>
    </div>

    <div>
      <label>Genre</label>
      <select id="genre">
        <option value="classical">Classical</option>
        <option value="jazz">Jazz</option>
        <option value="rock">Rock</option>
        <option value="metal">Metal</option>
      </select>
      <div class="genre-tip small" id="genreTip">Classical: lyrical & diatonic. Jazz: chromatic approaches & swing. Rock: pentatonic riffs. Metal: fast minor runs.</div>
    </div>

    <div>
      <label>Length (beats)</label>
      <input id="length" type="number" value="8" min="1" max="32" />
    </div>

    <div>
      <label>Number of notes</label>
      <input id="notesCount" type="number" value="12" min="1" max="64" />
    </div>

    <div>
      <label>Scalar ⇄ Leapy (0 = scalar, 1 = leapy)</label>
      <input id="leapy" type="range" min="0" max="1" step="0.01" value="0.25" />
      <div class="range-labels"><span>scalar</span><span>leapy</span></div>
    </div>

    <div>
      <label>Difficulty (1-easy → 5-hard)</label>
      <input id="difficulty" type="range" min="1" max="5" step="1" value="2" />
      <div class="range-labels"><span>1</span><span>5</span></div>
    </div>
  </div>

  <div class="footer">
    <div class="big">
      <button id="generate">Generate</button>
      <button id="play" class="secondary">Play</button>
      <button id="stop" class="secondary">Stop</button>
    </div>
    <div style="margin-left:auto" class="small">
      <span class="kbd">Tempo: <span id="tempoDisplay">100</span> BPM</span>
      <input id="tempo" type="range" min="60" max="180" value="100" style="width:120px;margin-left:8px"/>
    </div>
  </div>

  <div class="panel" id="panel">
    <div class="meta small">Generated notes:</div>
    <div id="notes" class="notes" aria-live="polite"></div>
    <div id="info" class="meta"></div>
  </div>
</div>

<!-- Tone.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
<script>
/* Lick Generator
   Principles:
   - Build scale (in semitones) from key + mode
   - Generate melody as sequence of scale-degree jumps based on leapy/difficulty
   - Apply genre templates (rhythm feel, allowed chromatic approaches, ornamentation)
   - Humanize: small timing/velocity variations + legato/slurs per genre
   - Use Tone.js PolySynth + reverb for pleasant mobile-friendly sound
*/

(() => {
  // Utilities
  const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const keyToMidi = (key) => {
    // assume middle octave around C4 = 60 base
    const idx = noteNames.indexOf(key.replace('♭','b').replace('♯','#'));
    const canonical = key.replace('b','b').replace('#','#');
    let baseIdx = noteNames.findIndex(n => n === canonical) ;
    if (baseIdx === -1) {
      // handle flat names (Db -> C# etc)
      const map = {'Db':'C#','Eb':'D#','Gb':'F#','Ab':'G#','Bb':'A#','Cb':'B','Fb':'E','E#':'F'};
      baseIdx = noteNames.indexOf(map[canonical] || 'C');
    }
    return 60 + baseIdx; // C4=60
  };

  const modeFormulas = {
    ionian: [0,2,4,5,7,9,11],
    dorian: [0,2,3,5,7,9,10],
    phrygian: [0,1,3,5,7,8,10],
    lydian: [0,2,4,6,7,9,11],
    mixolydian: [0,2,4,5,7,9,10],
    aeolian: [0,2,3,5,7,8,10],
    locrian: [0,1,3,5,6,8,10],
    harmonic_minor: [0,2,3,5,7,8,11],
    melodic_minor: [0,2,3,5,7,9,11],
    pentatonic_major: [0,2,4,7,9],
    pentatonic_minor: [0,3,5,7,10],
    chromatic: Array.from({length:12}, (_,i)=>i)
  };

  // genre templates
  const genres = {
    classical: {
      instrument: 'piano',
      tempoBase: 80,
      swing: 0,
      allowedChromaticApproach: 0.05,
      articulation: 'legato',
      intervalBias: d => Math.max(0, d*0.6), // prefer smaller jumps
      velocityRange: [0.5,0.9],
      rhythmComplexity: 0.35
    },
    jazz: {
      instrument:'sax',
      tempoBase: 120,
      swing: 0.55,
      allowedChromaticApproach: 0.35,
      articulation: 'smooth',
      intervalBias: d => d*0.8,
      velocityRange: [0.45,0.95],
      rhythmComplexity: 0.6
    },
    rock: {
      instrument:'electric',
      tempoBase: 110,
      swing: 0,
      allowedChromaticApproach: 0.08,
      articulation: 'punchy',
      intervalBias: d => d*0.7,
      velocityRange: [0.6,1.0],
      rhythmComplexity: 0.4
    },
    metal: {
      instrument:'metal',
      tempoBase: 140,
      swing: 0,
      allowedChromaticApproach: 0.02,
      articulation: 'staccato',
      intervalBias: d => d*1.2, // allows big runs
      velocityRange: [0.7,1.0],
      rhythmComplexity: 0.55
    }
  };

  // Tone.js setup
  const reverb = new Tone.Reverb({decay:3.2,wet:0.2}).toDestination();
  const masterVol = new Tone.Volume(-6).toDestination();
  reverb.connect(masterVol);

  // create simple voices per genre using Tone.js synths
  const createVoices = () => {
    const voices = {
      piano: new Tone.PolySynth(Tone.Synth, {
        oscillator: {type: 'sine'},
        envelope: {attack:0.02,decay:0.15,sustain:0.85,release:0.6}
      }).connect(reverb),
      sax: new Tone.PolySynth(Tone.Synth, {
        oscillator:{type:'sawtooth'},
        envelope:{attack:0.01,decay:0.08,sustain:0.9,release:0.2}
      }).connect(reverb),
      electric: new Tone.PolySynth(Tone.Synth, {
        oscillator:{type:'square'},
        envelope:{attack:0.005,decay:0.08,sustain:0.8,release:0.12}
      }).connect(reverb),
      metal: new Tone.PolySynth(Tone.Synth, {
        oscillator:{type:'triangle'},
        envelope:{attack:0.002,decay:0.02,sustain:0.6,release:0.04}
      }).connect(reverb)
    };
    Object.values(voices).forEach(v => v.volume.value = -2);
    return voices;
  };
  const voices = createVoices();

  // helpers
  function midiToNoteName(m) {
    const octave = Math.floor(m / 12) - 1;
    const name = noteNames[(m+120)%12];
    return name + octave;
  }
  function clamp(v,a,b){return Math.min(b,Math.max(a,v))}

  // Build scale MIDI note numbers
  function buildScale(keyName, modeName){
    const baseMidi = keyToMidi(keyName);
    const formula = modeFormulas[modeName] || modeFormulas.ionian;
    // build across several octaves to allow leaps
    const notes = [];
    for(let o=-1;o<=2;o++){
      for(let s of formula){
        notes.push(baseMidi + s + 12*o);
      }
    }
    notes.sort((a,b)=>a-b);
    return notes;
  }

  // Probability helpers for scalar vs leapy
  function pickInterval(separationWeight, maxSemitones=24){
    // separationWeight in [0,1] means probability of larger leaps
    // We'll pick from a distribution where P(interval) ~ exp(-k*|i|) with k related to separationWeight
    const k = 1.0 - separationWeight*0.9; // smaller k -> heavier tail -> more leaps
    // we sample via inverse transform of discrete distribution
    const probs = [];
    for(let i=0;i<=maxSemitones;i++){
      const p = Math.exp(-k*i);
      probs.push(p);
    }
    const sum = probs.reduce((a,b)=>a+b,0);
    const normalized = probs.map(p=>p/sum);
    const r = Math.random();
    let acc=0;
    for(let i=0;i<normalized.length;i++){
      acc += normalized[i];
      if(r<=acc) return i;
    }
    return 1;
  }

  // Create rhythm pattern across length and note count
  function makeRhythm(totalBeats, noteCount, complexity){
    // complexity 0..1 controls how syncopated/varied
    // We'll return array of start times (beats) and durations.
    // Simplest: split into noteCount slots but jitter durations.
    const items = [];
    const avgBeat = totalBeats / noteCount;
    let t = 0;
    for(let i=0;i<noteCount;i++){
      const jitter = (Math.random()*2-1) * complexity * (avgBeat*0.4);
      const start = clamp(t + jitter, 0, totalBeats - 0.02);
      // duration depends on complexity and random
      let dur = avgBeat * (0.5 + Math.random()*0.9*(1-complexity));
      dur = clamp(dur, 0.05, totalBeats - start);
      items.push({start, duration: dur});
      t += avgBeat;
    }
    // sort by start
    items.sort((a,b)=>a.start-b.start);
    return items;
  }

  // Generate melody
  function generateLick(opts){
    // opts: key, mode, genre, length(beats), notesCount, leapy(0..1), difficulty(1..5), tempo
    const scale = buildScale(opts.key, opts.mode);
    const g = genres[opts.genre];
    const tempo = opts.tempo || g.tempoBase;
    const maxRange = 24 + (opts.difficulty-1)*8; // harder -> can use wider range
    // pick starting note near middle of scale
    const mid = Math.floor(scale.length/2);
    let currentIndex = mid + Math.floor((Math.random()-0.5)*4);
    const rhythm = makeRhythm(opts.length, opts.notesCount, g.rhythmComplexity * (opts.difficulty/5));
    const notes = [];
    for(let i=0;i<opts.notesCount;i++){
      // decide interval size in semitones
      const intervalSemis = pickInterval(opts.leapy, Math.min(maxRange, 36));
      // choose direction biased by genre (metal maybe runs up/down)
      const dir = Math.random() < 0.5 ? -1 : 1;
      // convert semitones to nearest scale steps by finding target midi
      let candidateMidi = scale[currentIndex] + dir * intervalSemis;
      // snap to nearest scale degree available (nearest in scale array)
      let nearestIdx = 0;
      let nearestDiff = 1e9;
      for(let si=0;si<scale.length;si++){
        const d = Math.abs(scale[si] - candidateMidi);
        if(d < nearestDiff){
          nearestDiff = d; nearestIdx = si;
        }
      }
      // sometimes allow chromatic approach (especially jazz)
      if(Math.random() < g.allowedChromaticApproach && Math.random() < 0.5){
        // insert a chromatic passing tone before target by +/-1 semitone
        const chrom = clamp(candidateMidi + (Math.random()<0.5 ? -1 : 1), 36, 96);
        notes.push({
          midi: chrom,
          start: rhythm[i].start - (Math.random()*0.05),
          duration: rhythm[i].duration * 0.35,
          velocity: randRange(g.velocityRange),
          humanize: true
        });
      }
      currentIndex = nearestIdx;
      const midi = clamp(scale[currentIndex], 36, 96);
      // apply mode-specific ornamentation probability
      const ornament = (opts.genre === 'classical' && Math.random() < 0.12) ? 'grace' : null;
      notes.push({
        midi,
        start: rhythm[i].start,
        duration: rhythm[i].duration * (ornament ? 0.8 : (opts.genre==='metal' ? 0.2 : 0.6)),
        velocity: randRange(g.velocityRange),
        ornament
      });
      // small chance to create small neighbor tone
      if(Math.random() < 0.08 && opts.genre !== 'metal'){
        const neighborMidi = midi + (Math.random()<0.5 ? -1 : 1);
        notes.push({
          midi: neighborMidi,
          start: rhythm[i].start + (Math.random()*0.03),
          duration: 0.08,
          velocity: randRange([0.35, 0.7])
        });
      }
    }

    // sort by start
    notes.sort((a,b)=>a.start - b.start);
    // apply humanization per note: timing jitter & velocity variation depending on difficulty
    const humanized = notes.map(n => {
      const timeJitter = ((Math.random()*2-1) * 0.02) * (1/opts.difficulty); // easier more jitter
      const velJitter = ((Math.random()*2-1) * 0.06);
      return Object.assign({}, n, {
        start: clamp(n.start + timeJitter, 0, opts.length),
        velocity: clamp(n.velocity + velJitter, 0.02, 1)
      });
    });

    return {notes: humanized, tempo, scale, rhythm};
  }

  function randRange([a,b]){return a + Math.random()*(b-a)}

  // Playback
  let part = null;
  function playLick(data, opts){
    if(!data || !data.notes || data.notes.length===0) return;
    // ensure AudioContext started on user gesture
    Tone.start().then(() => {
      Tone.Transport.bpm.value = opts.tempo;
      Tone.Transport.cancel();
      if(part) part.dispose();
      // choose voice
      const voiceKey = genres[opts.genre].instrument;
      const synth = voices[voiceKey] || voices.piano;

      const events = data.notes.map(n => {
        // compute time in measures: Tone.Transport uses seconds or "0:0:0" ; we'll use seconds via Tone.Time
        return {
          time: Tone.Time(n.start + 'n').toSeconds ? Tone.Time(n.start + 'm').toSeconds() : n.start,
        };
      });
      // Instead we'll schedule using seconds relative to now with Tone.Transport.seconds offset
      const now = Tone.now() + 0.1;
      data.notes.forEach(n => {
        const secondsPerBeat = 60 / opts.tempo;
        const at = now + n.start * secondsPerBeat;
        const dur = Math.max(0.05, n.duration * secondsPerBeat);
        // humanize timing
        const jitter = (Math.random()*2-1) * 0.006 * (1/opts.difficulty);
        const startTime = at + jitter;
        // velocity to velocity (gain)
        const velocity = clamp(n.velocity, 0.02, 1);

        // articulation/legato adjustments by genre
        let release = dur * (opts.genre === 'metal' ? 0.2 : (opts.genre === 'classical' ? 1.1 : 0.6));
        if(n.ornament === 'grace') release = Math.min(release, 0.09);

        // schedule note
        synth.triggerAttackRelease(
          midiToNoteName(n.midi),
          release,
          startTime,
          velocity
        );
      });

      // small backing tone to give context (light pad / root touches)
      const backing = new Tone.PolySynth(Tone.Synth, {
        oscillator:{type:'sine'}, envelope:{attack:0.02,decay:0.1,sustain:0.5,release:1.2}
      }).connect(reverb);
      backing.volume.value = -18;
      // schedule sparse backing chords on beats for context
      for(let b=0;b<opts.length;b+=Math.max(1,Math.floor(4/(opts.difficulty)))){
        const chordRootMidi = data.scale[Math.floor(data.scale.length/2)] + (Math.random()<0.5?0:12);
        const ch = [chordRootMidi, chordRootMidi+4, chordRootMidi+7].map(m=>midiToNoteName(m));
        const at = now + b * (60/opts.tempo);
        backing.triggerAttackRelease(ch, 0.5, at, 0.08);
      }

      // Transport not necessary — we used absolute scheduling
      // cleanup after last note
      const lastStart = Math.max(...data.notes.map(n => n.start)) + 1.5;
      setTimeout(() => { backing.dispose(); }, (lastStart + 1)*1000);

    });
  }

  // UI wiring
  const $ = id => document.getElementById(id);
  const keySel = $('key'), modeSel = $('mode'), genreSel = $('genre'),
        lengthInput = $('length'), notesCountIn = $('notesCount'), leapyIn = $('leapy'),
        diffIn = $('difficulty'), generateBtn = $('generate'), playBtn = $('play'), stopBtn = $('stop'),
        notesDiv = $('notes'), infoDiv = $('info'), tempoIn = $('tempo'), tempoDisplay = $('tempoDisplay'),
        genreTip = $('genreTip');

  function updateGenreTip(){
    const g = genreSel.value;
    genreTip.textContent = {
      classical:'Classical: lyrical, diatonic phrases with occasional ornament.',
      jazz:'Jazz: chromatic approaches, swing feel, extended tensions, more chromaticism.',
      rock:'Rock: pentatonic/diatonic riffs, rhythmic punch and bends (simulated).',
      metal:'Metal: minor modes, fast runs and short staccato phrases.'
    }[g];
  }
  genreSel.addEventListener('change', updateGenreTip);
  tempoIn.addEventListener('input', ()=> tempoDisplay.textContent = tempoIn.value);

  let lastData = null;

  generateBtn.addEventListener('click', () => {
    const opts = readOpts();
    const data = generateLick(opts);
    lastData = {data, opts};
    renderData(data, opts);
  });

  playBtn.addEventListener('click', async () => {
    if(!lastData) {
      // auto-generate if none
      const opts = readOpts();
      lastData = {data: generateLick(opts), opts};
      renderData(lastData.data, lastData.opts);
    }
    // resume Tone context and play
    await Tone.start();
    playLick(lastData.data, lastData.opts);
  });

  stopBtn.addEventListener('click', () => {
    Tone.Transport.stop();
    // Tone.js doesn't provide a global stop for scheduled synths easily; we can suspend audio
    Tone.context.resume().then(()=>Tone.context.close().then(()=> {
      // re-create voices to be safe
      // Note: closing context on mobile can require user gesture to re-open; keep gentle
      // Instead we'll just set master volume low
      voices.piano.volume.value = -60;
      setTimeout(()=>voices.piano.volume.value = -2, 120);
    }));
  });

  function readOpts(){
    return {
      key: keySel.value,
      mode: modeSel.value,
      genre: genreSel.value,
      length: Number(lengthInput.value),
      notesCount: Number(notesCountIn.value),
      leapy: Number(leapyIn.value),
      difficulty: Number(diffIn.value),
      tempo: Number(tempoIn.value)
    };
  }

  function renderData(data, opts){
    // show note names + timings
    notesDiv.innerHTML = '';
    data.notes.forEach(n => {
      const el = document.createElement('div');
      el.className = 'note-pill';
      el.textContent = `${midiToNoteName(n.midi)} @${n.start.toFixed(2)} dur:${(n.duration).toFixed(2)}`;
      notesDiv.appendChild(el);
    });
    infoDiv.innerHTML = `
      <div class="small">Key: <strong>${opts.key} ${opts.mode}</strong> · Genre: <strong>${opts.genre}</strong> · Tempo: <strong>${opts.tempo} BPM</strong></div>
      <div class="small">Difficulty: ${opts.difficulty} · Scalar⇄Leapy: ${opts.leapy.toFixed(2)} · Beats: ${opts.length} · Notes: ${opts.notesCount}</div>
    `;
  }

  // small auto-generate first time
  (function init(){
    updateGenreTip();
    tempoDisplay.textContent = tempoIn.value;
    // produce initial lick
    const opts = readOpts();
    const data = generateLick(opts);
    lastData = {data, opts};
    renderData(data, opts);
  })();

})();
</script>
</body>
</html>
